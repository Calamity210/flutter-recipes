{
  
  "1": {
    "title": "Anatomy of a snapshot",
    "content": "Anatomy of a snapshot . The AOT snapshot itself is quite complex, it is a custom binary format with no documentation. You may be forced to step through the serialization process manually in a debugger to implement a tool that can read the format. . The source files relevant to snapshot generation can be found here: . Cluster serialization / deserialization [vm/clustered_snapshot.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/clustered_snapshot.h) [vm/clustered_snapshot.cc](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/clustered_snapshot.cc) | ROData serialization [vm/image_snapshot.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/image_snapshot.h) [vm/image_snapshot.cc](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/image_snapshot.cc) | ReadStream / WriteStream [vm/datastream.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/datastream.h) | Object definitions [vm/object.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/object.h) | ClassId enum [vm/class_id.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/class_id.h) | . It took me about two weeks to implement a command line utility that is capable of parsing a snapshot, giving us complete access to the heap of a compiled app. . As an overview, here is the layout of clustered snapshot data: . . Every RawObject* in the Isolate gets serialized by a corresponding SerializationCluster instance depending on its class id. These objects can contain anything from code, instances, types, primitives, closures, constants, etc. More on that later. . After deserializing the VM isolate snapshot, every object in its heap gets added to the Isolate snapshot object pool allowing them to be referenced in the same context. . Clusters are serialized in three stages: Trace, Alloc, and Fill. . In the trace stage, root objects are added to a queue along with the objects they reference in a breadth first search. At the same time a SerializationCluster instance is created corresponding to each class type. . Root objects are a static set of objects used by the vm in the isolate’s ObjectStore which we will use later to locate libraries and classes. The VM snapshot includes StubCode base objects which are shared between all isolates. . Stubs are basically hand written sections of assembly that dart code calls into, allowing it to communicate safely with the runtime. . After tracing, cluster info is written containing basic information about the clusters, most importantly the number of objects to allocate. . In the alloc stage, each clusters WriteAlloc method is called which writes any information needed to allocate raw objects. Most of the time all this method does is write the class id and number of objects that are part of this cluster. . The objects that are part of each cluster are also assigned an incrementing object id in the order they are allocated, this is used later during the fill stage when resolving object references. . You may have noticed the lack of any indexing and cluster size information, the entire snapshot has to be read fully in order to get any meaningful data out of it. So to actually do any reverse engineering you must either implement deserialization routines for 31+ cluster types (which I have done) or extract information by loading it into a modified runtime (which is difficult to do cross-architecture). . Here is a simplified example of what the structure of the clusters would be for an array [123, 42]: . . If an object references another object like an array element, the serializer writes the object id initially assigned during the alloc phase as shown above. . In the case of simple objects like Mints and Smis, they are constructed entirely in the alloc stage because they don’t reference any other objects. . After that the ~107 root refs are written including object ids for core types, libraries, classes, caches, static exceptions and several other miscellaneous objects. . Finally, ROData objects are written which are directly mapped to RawObject*s in-memory to avoid an extra deserialization step. . The most important type of ROData is RawOneByteString which is used for library / class / function names. ROData is also referenced by offset being the only place in the snapshot data where decoding is optional. . Similar to ROData, RawInstruction objects are direct pointers to snapshot data but are stored in the executable instruction symbol rather than main snapshot data. . Here is a dump of serialization clusters that are typically written when compiling an app: . #lint cluster-tbl idx | cid | ClassId enum | Cluster name -|--||- 0 | 5 | Class | ClassSerializationCluster 1 | 6 | PatchClass | PatchClassSerializationCluster 2 | 7 | Function | FunctionSerializationCluster 3 | 8 | ClosureData | ClosureDataSerializationCluster 4 | 9 | SignatureData | SignatureDataSerializationCluster 5 | 12 | Field | FieldSerializationCluster 6 | 13 | Script | ScriptSerializationCluster 7 | 14 | Library | LibrarySerializationCluster 8 | 17 | Code | CodeSerializationCluster 9 | 20 | ObjectPool | ObjectPoolSerializationCluster 10 | 21 | PcDescriptors | RODataSerializationCluster 11 | 22 | CodeSourceMap | RODataSerializationCluster 12 | 23 | StackMap | RODataSerializationCluster 13 | 25 | ExceptionHandlers | ExceptionHandlersSerializationCluster 14 | 29 | UnlinkedCall | UnlinkedCallSerializationCluster 15 | 31 | MegamorphicCache | MegamorphicCacheSerializationCluster 16 | 32 | SubtypeTestCache | SubtypeTestCacheSerializationCluster 17 | 36 | UnhandledException | UnhandledExceptionSerializationCluster 18 | 40 | TypeArguments | TypeArgumentsSerializationCluster 19 | 42 | Type | TypeSerializationCluster 20 | 43 | TypeRef | TypeRefSerializationCluster 21 | 44 | TypeParameter | TypeParameterSerializationCluster 22 | 45 | Closure | ClosureSerializationCluster 23 | 49 | Mint | MintSerializationCluster 24 | 50 | Double | DoubleSerializationCluster 25 | 52 | GrowableObjectArray | GrowableObjectArraySerializationCluster 26 | 65 | StackTrace | StackTraceSerializationCluster 27 | 72 | Array | ArraySerializationCluster 28 | 73 | ImmutableArray | ArraySerializationCluster 29 | 75 | OneByteString | RODataSerializationCluster 30 | 95 | TypedDataInt8Array | TypedDataSerializationCluster 31 | 143 | &lt;instance&gt; | InstanceSerializationCluster ... 54 | 463 | &lt;instance&gt; | InstanceSerializationCluster . There are a few more clusters that could potentially be in a snapshot, but these are the only ones I have seen in a Flutter app so far. . In DartVM there are a static set of predefined class IDs defined in the ClassId enum, 142 IDs as of Dart 2.4.0 to be exact. IDs outside of that (or do not have an associated cluster) are written with separate InstanceSerializationClusters. . Finally bringing the parser together I can view the structure of the snapshot from the ground up, starting with the libraries list in the root object table. . Using the object tree here’s how you can locate a top level function, in this case package:ftest/main.darts main: As you can see above the names of libraries, classes, and functions are included in release snapshots. . Dart can’t really remove them without also obfuscating stack traces, see: https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code . Obfuscation is probably not worth the effort but this will most likely change in the future and become more streamlined similar to proguard on Android or sourcemaps on the web. . The actual machine code is stored in Instructions objects pointed to by Code objects from an offset to the start of the instruction data. .",
    "url": "/docs/reverse-engineering/anatomy-of-a-snapshot.html",
    "relUrl": "/docs/reverse-engineering/anatomy-of-a-snapshot.html"
  }
  ,"2": {
    "title": "Android Emulator on AMD CPUs",
    "content": "Android Emulator on AMD CPUs . Windows . Do NOT install either HAXM or Hyper-V. | Make sure you have Android Studio 3.2 Beta 1 or higher. | Make sure virtualization is enabled in your BIOS, the option is sometimes labelled SVM. | . Install WHPX . Run optionalfeatures from the start menu, it should open the “Windows Features” dialog. | Check Windows Hypervisor Platform. | Click OK. | Reboot. | After WHPX is installed, the Android Emulator should ‘just work’. . Linux . Install kvm, it works on AMD out of the box. | . You can use the -accel-check option to check the status of virtualization: . #lint shell ping@debian:~$ Android/sdk/emulator/emulator -accel-check accel: 0 KVM (version 12) is installed and usable. .",
    "url": "/docs/faq/avd-amd.html",
    "relUrl": "/docs/faq/avd-amd.html"
  }
  ,"3": {
    "title": "The Dart SDK",
    "content": "The Dart SDK . Thankfully Dart is completely open source so we don’t have to fly blind when reverse engineering the snapshot format. . Before creating a testbed for generating and disassembling snapshots you have to set up the Dart SDK, there is documentation on how to build it here: https://github.com/dart-lang/sdk/wiki/Building. . You want to generate libapp.so files typically orchestrated by the flutter tool, but there doesn’t seem to be any documentation on how to do that yourself. . The flutter sdk ships binaries for gen_snapshot which is not part of the standard create_sdk build target you usually use when building dart. . It does exist as a separate target in the SDK though, you can build the gen_snapshot tool for arm with this command: . ./tools/build.py -m product -a simarm gen_snapshot . Normally you can only generate snapshots for the architecture you are running on, to work around that they have created sim targets which simulate snapshot generation for the target platform. This has some limitations such as not being able to make aarch64 or x86_64 snapshots on a 32 bit system. . Before making a shared object you have to compile a dill file using the front-end: . ~/flutter/bin/cache/dart-sdk/bin/dart ~/flutter/bin/cache/artifacts/engine/linux-x64/frontend_server.dart.snapshot --sdk-root ~/flutter/bin/cache/artifacts/engine/common/flutter_patched_sdk_product/ --strong --target=flutter --aot --tfa -Ddart.vm.product=true --packages .packages --output-dill app.dill package:foo/main.dart . Dill files are actually the same format as kernel snapshots, their format is specified here: https://github.com/dart-lang/sdk/blob/master/pkg/kernel/binary.md . This is the format used as a common representation of dart code between tools, including gen_snapshot and analyzer. . With the app.dill we can finally generate a libapp.so using this command: . gen_snapshot --causal_async_stacks --deterministic --snapshot_kind=app-aot-elf --elf=libapp.so --strip app.dill . Once you are able to manually generate the libapp.so, it is easy to modify the SDK to print out all of the debug information needed to reverse engineer the AOT snapshot format. . As a side note, Dart was actually designed by some of the people who created JavaScript’s V8 which is arguably the most advanced interpreter ever made. DartVM is incredibly well engineered and I don’t think people give its creators enough credit. .",
    "url": "/docs/reverse-engineering/dart-sdk.html",
    "relUrl": "/docs/reverse-engineering/dart-sdk.html"
  }
  ,"4": {
    "title": "Diagnostics",
    "content": "Diagnostics . Strategy . I always keep the following in mind when deciding whether to optimize a piece of code: . Does the issue exist on a real device in release mode? | Am I sure this piece of code impacts frame times? | Are the changes simple or are they likely to cause other issues? | Will the code still be maintainable after I do make changes? | . The worst thing you can do is premature optimization, spend as much time as reasonable diagnosing and understanding performance issues before hammering away. . If the problem is complex and only happens when special conditions are met i.e. “user visits page X and gets jank after scrolling down for some time”, it is very helpful to reproduce this issue in a more controlled scenario before making changes. . Jank . The most noticeable performance issue is Jank, which is when a small number of frames take much longer than they are supposed to. . The symptoms of jank are quite similar, but the underlying issue can vary significantly: . CPU Dart Expensive tasks e.g. parsing markdown | Excessive widget building | Garbage Collection | . | Native code Android APIs | Native views | . | . | GPU dart:ui Too many paint features | Poor handling of Image objects | . | Native code | . | Low memory Loading too many large assets e.g. images | Leaks | . | Power saving Low battery | . | . Sometimes multiple of these factors can impact frames at the same time, remember that if you think you have isolated one. . Performance testing should always be done in profile or release, on IntelliJ that can be configured like this: . .",
    "url": "/docs/performance/diagnostics.html",
    "relUrl": "/docs/performance/diagnostics.html"
  }
  ,"5": {
    "title": "experiment_not_enabled",
    "content": "experiment_not_enabled . You have gotten this warning, or something similar: . This requires the &#39;control-flow-collections&#39; experiment to be enabled. Try enabling this experiment by adding it to the command line when compiling and running.dart(experiment_not_enabled) . Do NOT modify analysis options to enable experiments like the message suggests. . The real issue is that your dart version constraint is too low, the solution is to upgrade it in your pubspec: . environment: sdk: &#39;&gt;=2.7.0 &lt;3.0.0&#39; . After you raise the version constraint, don’t forget to run pub get and restart your IDE. .",
    "url": "/docs/faq/experiment-not-enabled.html",
    "relUrl": "/docs/faq/experiment-not-enabled.html"
  }
  ,"6": {
    "title": "Hello, World!",
    "content": "Hello, World! . Cool, we can locate functions by name but how do we figure out what they actually do? . As expected reverse engineering from here on is a bit more difficult because we are digging through the assembly code contained in Instructions objects. . Instead of using a modern compiler backend like clang, Dart actually uses its JIT compiler for code generation but with a couple AOT specific optimizations. . If you have never worked with JIT code, it is a bit bloated in some places compared to what the equivalent C code would produce. Not that Dart is doing a bad job though, it’s designed to be generated quickly at runtime and the hand-written assembly for common instructions often beats clang/gcc in terms of performance. . Generated code being less micro-optimized actually works heavily to our advantage since it closer resembles the higher level IR used to generate it. . Most of the relevant code generation can be found in: . vm/compiler/backend/il_&lt;arch&gt;.cc | vm/compiler/assembler/assembler_&lt;arch&gt;.cc | vm/compiler/asm_intrinsifier_&lt;arch&gt;.cc | vm/compiler/graph_intrinsifier_&lt;arch&gt;.cc | . Here is the register layout and calling conventions for dart’s A64 assembler: . #lint reg-tbl r0 | | Returns r0 - r7 | | Arguments r0 - r14 | | General purpose r15 | sp | Dart stack pointer r16 | ip0 | Scratch register r17 | ip1 | Scratch register r18 | | Platform register r19 - r25 | | General purpose r19 - r28 | | Callee saved registers r26 | thr | Current thread r27 | pp | Object pool r28 | brm | Barrier mask r29 | fp | Frame pointer r30 | lr | Link register r31 | zr | Zero / CSP . This ABI follows the standard AArch64 calling conventions here but with a few global registers: . R26 / THR: Pointer to the running vm Thread, see vm/thread.h | R27 / PP: Pointer to the ObjectPool of the current context, see vm/object.h | R28 / BRM: The barrier mask, used for incremental garbage collection | . Similarly, this is the register layout for A32: . #lint reg-tbl r0 - r1 | | Returns r0 - r9 | | General purpose r4 - r10 | | Callee saved registers r5 | pp | Object pool r10 | thr | Current thread r11 | fp | Frame pointer r12 | ip | Scratch register r13 | sp | Stack pointer r14 | lr | Link register r15 | pc | Program counter . While A64 is a more common target I’ll mostly be covering A32 since its is simpler to read and disassemble. . You can view the IR along with the disassembly by passing --disassemble-optimized to gen_snapshot, but note this only works on the debug/release targets and not product. . As an example, when compiling hello world: . void hello() { print(&quot;Hello, World!&quot;); } . Scrolling down a bit in the disassembly you will find: . #lint dartvm-dasm Code for optimized function &#39;package:dectest/hello_world.dart_::_hello&#39; { ;; B0 ;; B1 ;; Enter frame 0xf69ace60 e92d4800 stmdb sp!, {fp, lr} 0xf69ace64 e28db000 add fp, sp, #0 ;; CheckStackOverflow:8(stack=0, loop=0) 0xf69ace68 e59ac024 ldr ip, [thr, #+36] 0xf69ace6c e15d000c cmp sp, ip 0xf69ace70 9bfffffe blls +0 ; 0xf69ace70 ;; PushArgument(v3) 0xf69ace74 e285ca01 add ip, pp, #4096 0xf69ace78 e59ccfa7 ldr ip, [ip, #+4007] 0xf69ace7c e52dc004 str ip, [sp, #-4]! ;; StaticCall:12( print&lt;0&gt; v3) 0xf69ace80 ebfffffe bl +0 ; 0xf69ace80 0xf69ace84 e28dd004 add sp, sp, #4 ;; ParallelMove r0 &lt;- C 0xf69ace88 e59a0060 ldr r0, [thr, #+96] ;; Return:16(v0) 0xf69ace8c e24bd000 sub sp, fp, #0 0xf69ace90 e8bd8800 ldmia sp!, {fp, pc} 0xf69ace94 e1200070 bkpt #0x0 } . What is printed here is slightly different from a snapshot built in product but the important part is that we can see the IR instructions alongside assembly. . Breaking it down: . #lint dartvm-dasm ;; Enter frame 0xf6a6ce60 e92d4800 stmdb sp!, {fp, lr} 0xf6a6ce64 e28db000 add fp, sp, #0 . This is a standard function prologue, the frame pointer of the caller and link register are pushed to the stack after which the frame pointer is set to the bottom of the function stack frame. . As with the standard ARM ABI, this uses a full-descending stack meaning it grows backwards in memory. . #lint dartvm-dasm ;; CheckStackOverflow:8(stack=0, loop=0) 0xf6a6ce68 e59ac024 ldr ip, [thr, #+36] 0xf6a6ce6c e15d000c cmp sp, ip 0xf6a6ce70 9bfffffe blls +0 ; 0xf6a6ce70 . This is a simple routine which does what you probably guessed, checks if the stack overflowed. . Sadly their disassembler does not annotate either thread fields or branch targets so you have to do some digging. . A list of field offsets can be found in vm/compiler/runtime_offsets_extracted.h, which defines Thread_stack_limit_offset = 36 telling us that the field accessed is the threads stack limit. . After the stack pointer is compared, it calls the stackOverflowStubWithoutFpuRegsStub stub if it has overflowed. The branch target in the disassembly appears to be un-patched but we can still inspect the binary afterwards to confirm. . #lint dartvm-dasm ;; PushArgument(v3) 0xf6a6ce74 e285ca01 add ip, pp, #4096 0xf6a6ce78 e59ccfa7 ldr ip, [ip, #+4007] 0xf6a6ce7c e52dc004 str ip, [sp, #-4]! . Here an object from the object pool is pushed onto the stack. Since the offset is too big to fit in an ldr offset encoding it uses an extra add instruction. . This object is in fact our “Hello, World!” string as a RawOneByteString* stored in the globalObjectPool of our isolate at offset 8103. . You may have noticed that offsets are misaligned, this is because object pointers are tagged with kHeapObjectTag from vm/pointer_tagging.h, in this case all of the pointers to RawObjects in compiled code are offset by 1. . #lint dartvm-dasm ;; StaticCall:12( print&lt;0&gt; v3) 0xf6a6ce80 ebfffffe bl +0 ; 0xf6a6ce80 0xf6a6ce84 e28dd004 add sp, sp, #4 . Here print is called followed by the string argument being popped from the stack. . Like before the branch hasn’t been resolved, it is a relative branch to the entry point for print in dart:core. . #lint dartvm-dasm ;; ParallelMove r0 &lt;- C 0xf69ace88 e59a0060 ldr r0, [thr, #+96] . Null is loaded into the return register, 96 being the offset to the null object field in a Thread. . #lint dartvm-dasm ;; Return:16(v0) 0xf69ace8c e24bd000 sub sp, fp, #0 0xf69ace90 e8bd8800 ldmia sp!, {fp, pc} 0xf69ace94 e1200070 bkpt #0x0 . And finally the function epilogue, the stack frame is restored along with any callee-saved registers. Since lr was pushed last, popping it into pc will cause the function to return. . From now on I’ll be using snippets from my own disassembler which has less problems than the builtin one. .",
    "url": "/docs/reverse-engineering/hello-world.html",
    "relUrl": "/docs/reverse-engineering/hello-world.html"
  }
  ,"7": {
    "title": "Ignoring overflow",
    "content": "Ignoring overflow . If you are here, you are probably looking for a parameter or configuration option to get rid of an annoying overflow error. Of course if it were that simple, this post would not exist. . In the majority of cases this is due to a faulty layout plain and simple, I’m going to give the benefit of the doubt and assume you have a legitimate reason for needing overflow. . The only two widgets that throw this error are Flex (Row / Column) and UnconstrainedBox, the former is obviously the most common. . The problem is not actually the fault of the Flex itself, rather the constraints given by its parent. In order to solve this issue the main axis constraint needs to be unbounded i.e. have a maximum main axis size of double.infinity. . The simplest way to give your layout the desired constraints is to use OverflowBox: . OverflowBox( maxWidth: double.infinity, child: Row(children: [ Some(), Long(), Widgets(), ]), ) . I’ve seen some people use Wrap to achieve a similar result, I highly discourage that because the fact that Wrap doesn’t check for overflow is probably an oversight and may be fixed in the future. .",
    "url": "/docs/faq/ignore-overflow.html",
    "relUrl": "/docs/faq/ignore-overflow.html"
  }
  ,"8": {
    "title": "FAQ",
    "content": "FAQ . A bunch of commonly asked questions on Discord. .",
    "url": "/docs/faq/",
    "relUrl": "/docs/faq/"
  }
  ,"9": {
    "title": "Architecture",
    "content": "Architecture . Everything related to state management, networking, organization, etc. .",
    "url": "/docs/architecture/",
    "relUrl": "/docs/architecture/"
  }
  ,"10": {
    "title": "Performance",
    "content": "Performance . This category is about performance related topics like best practices and debugging. .",
    "url": "/docs/performance/",
    "relUrl": "/docs/performance/"
  }
  ,"11": {
    "title": "Framework",
    "content": "Framework . Information about framework internals, e.g. Elements and RenderObjects. .",
    "url": "/docs/framework/",
    "relUrl": "/docs/framework/"
  }
  ,"12": {
    "title": "Packages",
    "content": "Packages . Here are some packages I have published: . boxy . This library provides several widgets and utilities that enable you to create advanced layouts without in-depth knowledge of the framework and minimal boilerplate. . pub.dev github . async_builder . This package provides AsyncBuilder, a widget similar to StreamBuilder / FutureBuilder which is designed to reduce boilerplate and improve error handling. . It also provides InitBuilder, which makes it easier to start async tasks safely. . pub.dev github . spa . This is a Dart implementation of the Solar Position Algorithm (SPA) by Ibrahim Reda and Afshin Andreas which is used by the U.S. government for radiology and energy purposes. See the paper here: https://www.nrel.gov/docs/fy08osti/34302.pdf . Given an observers coordinates and DateTime it can calculate the position of the sun and other information such as when the sun rises and sets. . pub.dev github .",
    "url": "/docs/packages/",
    "relUrl": "/docs/packages/"
  }
  ,"13": {
    "title": "Reverse Engineering",
    "content": "Most of this section is part of my blog post, you can check it out here. . Reverse Engineering . To start this journey I’ll cover some backstory on the Flutter stack and how it works. . What you probably already know: Flutter was built from the ground up with its own render pipeline and widget library, allowing it to be truly cross platform and have a consistent design and feel no matter what device its running on. . Unlike most platforms, all of the essential rendering components of the flutter framework (including animation, layout, and painting) are fully exposed to you in package:flutter. . You can see these components in the official architecture diagram from wiki/The-Engine-architecture: . . From a reverse engineering perspective the most interesting part is is the Dart layer since that is where all of the app logic sits. . But what does the Dart layer look like? . Flutter compiles your Dart to native assembly code and uses formats that have not been publicly documented in-depth let alone fully decompiled and recompiled. . For comparison other platforms like React Native just bundle minified javascript which is trivial to inspect and modify, additionally the bytecode for Java on Android is well documented and there are many free decompilers for it. . Despite the lack of obfuscation (by default) or encryption, Flutter apps are still extremely difficult to reverse engineer at the moment since it requires in-depth knowledge of Dart internals to even scratch the surface. . This makes Flutter very good from an intellectual property perspective, your code is almost safe from prying eyes. Next I’ll show you the build process of Flutter applications and explain in detail how to reverse engineer the code that it produces. .",
    "url": "/docs/reverse-engineering/",
    "relUrl": "/docs/reverse-engineering/"
  }
  ,"14": {
    "title": "About",
    "content": "About - ping’s cookbook . This site is where I post helpful information about Flutter and Dart. . If you have any questions, feel free to ping my on Discord, my username is ping#0001. . my website github discord .",
    "url": "/",
    "relUrl": "/"
  }
  ,"15": {
    "title": "IntelliJ Observatory",
    "content": "IntelliJ Observatory . The Flutter plugin removed the ability to open the observatory, this is quite annoying. . Here is a tampermonkey script that puts an observatory button on the top right of DevTools: . // ==UserScript== // @name DevTools Observatory button // @namespace https://me.tst.sh/ // @version 0.1 // @description try to take over the world! // @author ping // @match http://127.0.0.1:*/?ide=* // @grant none // ==/UserScript== (function() { &#39;use strict&#39;; function getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(&#39;&amp;&#39;); for (var i = 0; i &lt; vars.length; i++) { var pair = vars[i].split(&#39;=&#39;); if (decodeURIComponent(pair[0]) == variable) { return decodeURIComponent(pair[1]); } } console.log(&#39;Query variable %s not found&#39;, variable); } var uri = getQueryVariable(&quot;uri&quot;); console.log(&quot;Observatory url: &quot; + uri); document.querySelector(&quot;#try-flutter-web-devtools&quot;).parentElement.insertAdjacentHTML( &#39;beforeend&#39;, &#39;&lt;div class=&quot;masthead-item action-button active&quot; id=&quot;open-observatory&quot; title=&quot;Open Observatory&quot;&gt;&lt;span class=&quot;octicon octicon-clock&quot;&gt;&lt;/span&gt;&lt;/div&gt;&#39; ); var openObservatory = document.querySelector(&quot;#open-observatory&quot;); openObservatory.onclick = function () { location.href = uri; } })(); .",
    "url": "/docs/faq/intellij-observatory.html",
    "relUrl": "/docs/faq/intellij-observatory.html"
  }
  ,"16": {
    "title": "Nesting async builders",
    "content": "Nesting async builders . Basic nesting . Sometimes you might want a widget to depend on the result of multiple asynchronous tasks, including having one request depend on the result of another. . In this example we are calling getUser with a userId string to get a User object, then once that is complete we call user.searchFriends to get a Friends, finally once that is complete we build a Text that uses them: . build(context) =&gt; InitBuilder.arg&lt;Future&lt;User&gt;, String&gt;( getter: getUser, arg: userId, builder: (context, future) =&gt; AsyncBuilder&lt;User&gt;( future: future, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, user) =&gt; InitBuilder.arg&lt;Future&lt;Friends&gt;, String&gt;( getter: user.searchFriends, arg: queryString, builder: (context, future) =&gt; AsyncBuilder&lt;Friends&gt;( future: future, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, friends) =&gt; Text(&#39;Name: ${user.name} Friends: $friends&#39;), ), ), ), ); . Other than being ugly, this can also cause the progress indicator to look like its stuttering as it would get re-created when the first future completes. . What you should do instead is make a function that completes with every value required by the UI at once: . static Tuple2&lt;User, Friends&gt; getUserAndFriends( String userId, String queryString, ) async { var user = await getUser(userId); var friends = await user.searchFriends(queryString); return Tuple2(user, friends); } build(context) =&gt; InitBuilder.arg2&lt;Future&lt;Tuple2&lt;User, Friends&gt;&gt;, String, String&gt;( getter: getUserAndFriends, arg1: userId, arg2: queryString, builder: (context, future) =&gt; AsyncBuilder( future: future, builder: (context, tuple) =&gt; Text(&#39;Name: ${tuple.item1.name} Friends: ${tuple.item2}&#39;), ), ); . In this case we’re using a Tuple2 from package:tuple to return two values at the same time. . Streams . Another common problem is when you build widgets from a stream, but then need to make another request to make depending on the information from the stream. . In this example, we take a stream of Users rather than a future, but requests Friends in the same way: . build(context) =&gt; InitBuilder&lt;Stream&lt;User&gt;, String&gt;( getter: getUsers, builder: (context, stream) =&gt; AsyncBuilder( stream: stream, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, user) =&gt; InitBuilder.arg&lt;String, Friends&gt;( getter: user.searchFriends, arg: queryString, builder: (context, future) =&gt; AsyncBuilder( future: future, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, friends) =&gt; Text(&#39;Name: ${user.name} Friends: $friends&#39;), ), ), ), ); . What you can do instead is use Stream.asyncMap to add friends to the stream so that we only need a single builder: . static Stream&lt;Tuple2&lt;User, Friends&gt;&gt; getUsersAndFriends( String queryString, ) =&gt; getUsers().asyncMap((user) async =&gt; Tuple2(user, await user.getFriends(queryString))); build(context) =&gt; InitBuilder.arg&lt;Stream&lt;Tuple2&lt;User, Friends&gt;&gt;, String&gt;( getter: getUsersAndFriends, arg: queryString, builder: (context, stream) =&gt; AsyncBuilder( stream: stream, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, tuple) =&gt; Text(&#39;Name: ${tuple.item1.name} Friends: ${tuple.item2}&#39;), ), ); .",
    "url": "/docs/architecture/nesting-async-builders.html",
    "relUrl": "/docs/architecture/nesting-async-builders.html"
  }
  ,"17": {
    "title": "RawObject",
    "content": "RawObject . Under the hood all managed objects in DartVM are called RawObjects, in true DartVM fashion these classes are all defined in a single 3,000 line file found at vm/raw_object.h. . In generated code you can access and move around RawObject*s however you want as long as you yield according to an incremental write barrier mask, the GC appears to be able to track references through passive scanning alone. . Here is the class tree: . . RawInstances are the traditional Objects you pass around Dart code and invoke methods on, all of them have an equivalent type in dart land. Non-instance objects however are internal and only exist to leverage reference tracking and garbage collection, they do not have equivalent dart types. . Each object starts with a uint32_t containing the following tags: . . Class IDs here are the same as before with cluster serialization, they are defined in vm/class_id.h but also include user-defined starting at kNumPredefinedCids. . Size and GC data tags are used for garbage collection, most of the time they can be ignored. . If the canonical bit is set that means that this object is unique and no other object is equal to it, like with Symbols and Types. . Objects are very light and the size of RawInstance is usually only 4 bytes, they surprisingly do not use virtual methods at all either. . All of this means allocating an object and filling in its fields can be done virtually for free, something we do quite lot in Flutter. .",
    "url": "/docs/reverse-engineering/rawobject.html",
    "relUrl": "/docs/reverse-engineering/rawobject.html"
  }
  ,"18": {
    "title": "Safe Async",
    "content": "Safe Async . Common mistake . Quite frequently I see code using FutureBuilder or StreamBuilder incorrectly: . StreamBuilder&lt;DocumentSnapshot&gt;( stream: Firestore.instance.collection(&#39;foobar&#39;).snapshots(), builder: (context, snapshot) { if (snapshot.hasData) { return Text(&#39;${snapshot.data}&#39;); } else { return CircularProgressIndicator(); } }, ) . Despite looking quite innocent, this is problematic for a few reasons: . Errors from the AsyncSnapshot are silently ignored. | An async task is started during build, which will re-start when rebuilt. | Direct query instead of a request through state management or a network layer. | Thankfully these issues are easy to fix, the rest of this post provides in-depth suggestions for each. . . Error handling . FutureBuilder and StreamBuilder have flaws when it comes to error handling, the only way to know if an error has occurred is to manually either: . Use Future.catchError or Stream.handleError, requiring an extra closure. | Print the error in the AsyncSnapshot without a stack trace, duplicating the message when it rebuilds. | This is far from ideal, thankfully there is a better solution in package:async_builder. This package provides the AsyncBuilder Widget which allows you to rewrite the above code to the following: . AsyncBuilder&lt;DocumentSnapshot&gt;( stream: Firestore.instance.collection(&#39;foobar&#39;).snapshots(), waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, data) =&gt; Text(&#39;$data&#39;), ) . This will properly handle errors emitted by the stream or future, including printing the stack trace and other debug information like where the widget is located in the tree. . That solves error handling, but this sample code still has another flaw which is that building it has side effects. . . Avoiding build side effects . If you call a function directly to start an asynchronous task during build, that task will restart whenever the widget re-builds, potentially causing loss of state, infinite loops, and annoying flashes. . So starting asynchronous tasks like Firestore.instance.collection(&#39;foobar&#39;).snapshots() during build is bad practice, what should we do instead? . The two approaches I will cover are: . The widget solution | The state management solution | . The Widget solution . The most basic solution is to create a new StatefulWidget and start the asynchronous task inside of initState. . class _MyWidetState extends State&lt;MyWidet&gt; { Stream&lt;DocumentSnapshot&gt; foobar; @override void initState() { super.initState(); foobar = Firestore.instance.collection(&#39;foobar&#39;).snapshots(); } @override Widget build(BuildContext context) =&gt; AsyncBuilder( stream: foobar, builder: (context, snapshot) =&gt; ..., ); } . Now our request will not restart every build, nice! . We can do better though, package:async_builder also includes InitBuilder which is a widget that can initialize and cache our stream safely. . Instead of creating a whole new StatefulWidget, we can do this instead: . class MyWidget extends StatelessWidget { static Stream&lt;DocumentSnapshot&gt; getFoobar() =&gt; Firestore.instance.collection(&#39;foobar&#39;).snapshots(); @override Widget build(BuildContext context) =&gt; InitBuilder( getter: getFoobar, builder: (context, stream) =&gt; AsyncBuilder&lt;DocumentSnapshot&gt;( stream: stream, waiting: (context) =&gt; ..., builder: (context, snapshot) =&gt; ..., ), ); } . Making getFoobar static here is important, if we pass it an anonymous function directly it would be forced to make the request every build because the closure instance would be different. . But what if your getter takes arguments, like requesting from an http api for example? . With StatefulWidget, this is a bit involved because you have to check if the key changed after being rebuilt: . class MyWidget extends StatefulWidget { MyWidget({this.keyName}); final String keyName; @override _MyWidgetState createState() =&gt; _MyWidgetState(); } class _MyWidetState extends State&lt;MyWidet&gt; { Future&lt;String&gt; future; void updateFuture() { future = api.getString(widget.keyName); } @override void initState() { super.initState(); updateFuture(); } @override void didUpdateWidget(MyWidget oldWidget) { if (widget.keyName != oldWidget.keyName) { updateFuture(); } } @override Widget build(BuildContext context) =&gt; AsyncBuilder( stream: future, builder: (context, value) =&gt; Text(&#39;$value&#39;), ); } . With the InitBuilder.arg constructor this can be rewritten as: . class MyWidget extends StatelessWidget { MyWidget({this.keyName}); final String keyName; @override Widget build(BuildContext context) =&gt; InitBuilder.arg&lt;String, String&gt;( getter: api.getString, arg: keyName, builder: (context, future) =&gt; AsyncBuilder( future: future, builder: (context, value) =&gt; Text(&#39;$value&#39;), ), ); } . And you are done! The last four examples are safe to use. . . The state management solution . Using state management here has two benefits, first it allows you to avoid multiple widgets requesting snapshots at the same time, second it allows you swap out the underlying supplier of information whether it be for tests or to migrate away from firebase. . For a continuously updating resource, package:rxdart BehaviorSubjects are a very nice way to hold a value and notify listeners at the same time: . class MyService { ... BehaviorSubject&lt;Foobar&gt; _foobar; // Don&#39;t forget to dispose! ValueStream&lt;Foobar&gt; get foobar =&gt; _foobar ??= BehaviorSubject&lt;Foobar&gt;()..addStream( Firestore.instance .collection(&#39;foobar&#39;).snapshots().map((e) =&gt; Foobar.fromJson(e.data)) ); ... } . This basically just creates a BehaviorSubject that wraps snapshots from the firestore, allowing listeners to have an up to date Foobar without making any new requests. . The important part is that the instance is cached, which is very important to prevent side effects. . AsyncBuilder&lt;DocumentSnapshot&gt;( stream: MyService.of(context).foobar, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, data) =&gt; Text(&#39;$data&#39;), ) . With AsyncBuilder, the builder can use the current value of our BehaviorSubject on first build, avoiding the single-frame loading indicator that StreamBuilder would show. . If you want something a bit lighter consider using ValueNotifier / ValueListenableBuilder instead. . But what if you are requesting something based on its key like in the last two StatefulWidget examples? . What I typically do in this case is cache the futures or streams in a map: . class MyService { ... final MyApi api; var _foobars = &lt;String, Future&lt;Foobar&gt;&gt;{}; Future&lt;Foobar&gt; getFoo(String key) =&gt; _foobars[key] ??= api.getFoobar(key) ..then((value) =&gt; _foobars[key] = SynchronousFuture(value)); ... } . Like before, any tasks created by the service are cached to ensure work isn’t being duplicated. . I’m assigning SynchronousFuture because it allows the value to be available on first build if cached, similar to the ValueStream example. . class MyWidget extends StatelessWidget { MyWidget({this.keyName}); final String keyName; @override Widget build(BuildContext context) =&gt; AsyncBuilder&lt;Foobar&gt;( future: MyService.of(context).getFoo(keyName), waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, data) =&gt; Text(&#39;$data&#39;), ); } . These are some basic patterns that may or may not apply to your use case, if there is anything missing or if you have questions please don’t hesitate to ping me on Discord. . .",
    "url": "/docs/architecture/safe-async.html",
    "relUrl": "/docs/architecture/safe-async.html"
  }
  ,"19": {
    "title": "Snapshots",
    "content": "Snapshots . The Dart SDK is highly versatile, you can embed Dart code in many different configurations on many different platforms. . The simplest way to run Dart is to use the dart executable which just reads dart source files directly like a scripting language. It includes the primary components we call the front-end (parses Dart code), runtime (provides the environment for code to run in), and the JIT compiler. . You can also use dart to create and execute snapshots, a pre-compiled form of Dart which is commonly used to speed up frequently used command line tools (like pub). . #lint shell ping@debian:~/Desktop$ time dart hello.dart Hello, World! real 0m0.656s user 0m0.920s sys 0m0.084s ping@debian:~/Desktop$ dart --snapshot=hello.snapshot hello.dart ping@debian:~/Desktop$ time dart hello.snapshot Hello, World! real 0m0.105s user 0m0.208s sys 0m0.016s . As you can see, the start-up time is significantly lower when you use snapshots. . The default snapshot format is kernel, an intermediate representation of Dart code equivalent to the AST. . When running a Flutter app in debug mode, the flutter tool creates a kernel snapshot and runs it in your android app with the debug runtime + JIT. This gives you the ability to debug your app and modify code live at runtime with hot reload. . Unfortunately for us, using your own JIT compiler is frowned upon in the mobile industry due to increased concerns of RCEs. iOS actually prevents you from executing dynamically generated code like this entirely. . There are two more types of snapshots though, app-jit and app-aot, these contain compiled machine code that can be initialized quicker than kernel snapshots but aren’t cross-platform. . The final type of snapshot, app-aot, contains only machine code and no kernel. These snapshots are generated using the gen_snapshots tool found in flutter/bin/cache/artifacts/engine/&lt;arch&gt;/&lt;target&gt;/, more on that later. . They are a little more than just a compiled version of Dart code though, in fact they are a full “snapshot” of the VMs heap just before main is called. This is a unique feature of Dart and one of the reasons it initializes so quickly compared to other runtimes. . Flutter uses these AOT snapshots for release builds, you can see the files that contain them in the file tree for an Android APK built with flutter build apk: . #lint shell ping@debian:~/Desktop/app/lib$ tree . . ├── arm64-v8a │ ├── libapp.so │ └── libflutter.so └── armeabi-v7a ├── libapp.so └── libflutter.so . Here you can see the two libapp.so files which are a64 and a32 snapshots as ELF binaries. . The fact that gen_snapshots outputs an ELF / shared object here might be a bit misleading, it does not expose dart methods as symbols that can be called externally. Instead, these files are containers for the “clustered snapshot” format but with compiled code in the separate executable section, here is how they are structured: . #lint shell ping@debian:~/Desktop/app/lib/arm64-v8a$ aarch64-linux-gnu-objdump -T libapp.so libapp.so: file format elf64-littleaarch64 DYNAMIC SYMBOL TABLE: 0000000000001000 g DF .text 0000000000004ba0 _kDartVmSnapshotInstructions 0000000000006000 g DF .text 00000000002d0de0 _kDartIsolateSnapshotInstructions 00000000002d7000 g DO .rodata 0000000000007f10 _kDartVmSnapshotData 00000000002df000 g DO .rodata 000000000021ad10 _kDartIsolateSnapshotData . The reason why AOT snapshots are in shared object form instead of a regular snapshot file is because machine code generated by gen_snapshot needs to be loaded into executable memory when the app starts and the nicest way to do that is through an ELF file. . With this shared object, everything in the .text section will be loaded into executable memory by the linker allowing the Dart runtime to call into it at any time. . You may have noticed there are two snapshots: the VM snapshot and the Isolate snapshot. . DartVM has a second isolate that does background tasks called the vm isolate, it is required for app-aot snapshots since the runtime can’t dynamically load it in as the dart executable would. .",
    "url": "/docs/reverse-engineering/snapshots.html",
    "relUrl": "/docs/reverse-engineering/snapshots.html"
  }
  ,"20": {
    "title": "Strategy",
    "content": "Timeline . The most useful tool for diagnosing issues is the Observatory timeline, you can use it to quickly diagnose problematic frames. . Unfortunately the observatory button was removed by the Flutter plugin, see IntelliJ Observatory for an easy way to open it. . Keep in mind timelines can be skewed by external factors such as low memory, it’s always good to double check by enabling performance overlays in the developer options. . Workflow . My general workflow goes as follows: . Run the app in profile mode. | Open the observatory. | Click “view timeline” under VM information. . . | Click “Flutter Developer”: . . | Prepare the device to produce problematic frames e.g. open the ListView. | Click clear in the top right. . . | Perform the action that produce problematic frames. | Click refresh. | Use the pan and zoom tools to locate a bad frame: . . Make sure you scroll vertically to the ui and raster threads, bad frames will stick out like this: . . | For ui thread problems like shown above, click the timeline event and then the overlapping samples: . . | Locate problematic functions in the samples below: . . Here we can see the root cause of the jank, I’m doing too much work in a closure in _HomePageState.build. . | Complex widgets . Unfortunately the culprit might not be a single function, but instead emerge from large complex widgets. . TODO .",
    "url": "/docs/performance/timeline.html",
    "relUrl": "/docs/performance/timeline.html"
  }
  ,"21": {
    "title": "Type system",
    "content": "Type system . What are types . A type is a definition used to describe the interface an instance can have, here are a few examples: . // Foo is now an interface type. class Foo {} // FooFn is now an alias of the `Foo Function()` type. typedef FooFn = Foo Function(); // You can now create interface types of Bar with any subtype of Foo as the type argument. class Bar&lt;T extends Foo&gt; { // T is a subtype of Foo in this context. } . At the highest level, there are only a handful kinds of types: . dynamic | void | interface types | function types | parameter types | The most common is interface types, which describe a class with its resolved type arguments. . dart:core contains a bunch of classes with special type properties, I’ll cover those below. . Instances . Throughout an object’s lifetime, it has a single type, this type is determined when constructed and can never be changed: . int x = 2; num y = x; print(x is int); // true print(y is int); // true int z = y as int; // works . The type used to declare a variable is only the interface, it can store any assignable instance that implements said interface. . Methods . When you call a method on an instance, the type the instance was created with always determines the implementation of that method, for example: . class Foo { void hi() =&gt; print(&quot;i am foo&quot;); } class Bar implements Foo { void hi() =&gt; print(&quot;i am bar&quot;); } void callHi(Foo foo) =&gt; foo.hi(); void main() { callHi(Bar()); // prints &quot;i am bar&quot; } . Here, Bar’s implementation of hi will always override calls from its instances, regardless of what context its in. . All types visible to dart code are a subtype of Object and inherit the default implementation of its interface. . Dart is strongly typed, that means the compiler can make strong guarantees about the type a value will have at runtime. . Strong typing does not mean methods are guaranteed to exist though, if a method is missing when called, dart calls the noSuchMethod method which will throw a NoSuchMethodError by default. . (42 as dynamic).foo(); // throws NoSuchMethodError . All field access on instances is done through calls to setter and getter methods. . When you declare a field inside of a class, it implicitly declares setter and getter methods that read and write to an internal variable. This is different from C# for example, where setters / getters and fields are incompatible declarations. . class Foo { int a; // This declares both set:a and get:a } class Bar extends Foo { int get a =&gt; super.a * 2; // This overrides get:a without touching set:a } main() { var foo = Bar(); foo.a = 2; print(foo.a); // prints 4 } . Assignability . A variable can contain values that are not actual subtypes of its declared type, specifically null: . int x; print(x is int); // false . This prints false because the is operator is a subtype check, not an assignability check. . The as operator on the other hand does do an assignability check: . int x; print(x as int); // null, works . This is because a value x is assignable to T if either: . x’s runtime type is a subtype of T. | x is null and T is nullable. | Null vs void vs dynamic vs Object . The Null class is special, it throws a formatted NoSuchMethodError when methods other than get:hashCode, get:runtimeType, and operator== are called. . The dynamic and void types are both effectively an alias for Object, but change how visible methods are: . With Object, you can only access methods from the Object interface (just like a regular class), i.e. hashCode. | With void, you can store and cast, but not access any methods. | With dynamic, you can access any methods and call it with any arguments, those return values are also treated as dynamic. | . Closures . Extraction is the process of taking an instance method and turning it into a closure, this is commonly called a tear-off. . Methods can be extracted by calling the getter with their name: . typedef ToStringFn = String Function(); ToStringFn getToString(Object x) =&gt; x.toString; . In this example we extract the toString method from an arbitrary object x, giving us a closure that can be called as if it was a regular instance call on x. . The above code is effectively the same thing as: . typedef ToStringFn = String Function(); ToStringFn getToString(Object x) =&gt; () =&gt; x.toString(); . Except the former is a bit more efficient. . Functions are very special, they can actually refer to two different things: . Function types declared with arguments and return type, i.e. void Function() foo;. | The Function class as an interface type, which is a super type of any function. | Function types are similar to generic interface types, but can describe parameter names and types. . All function types are subtypes of Function, regardless of their return type and arguments: . print(print is Function); // true . Callable classes . Classes can be callable… kinda. . class Foo { void call() =&gt; print(&#39;hi&#39;); } void main() { Foo()(); // prints &quot;hi&quot; } . This is actually a little deceiving, Foo instances themselves are not actually callable, what’s happening is that the call method is being implicitly extracted. . Implicit tear-offs have some caveats, for example: . void callFoo(void Function() x) { print(x is Foo); // false print(x is Function); // true x(); } void main() { var x = Foo(); print(x is Foo); // true print(x is Function); // false callFoo(x); } . The x here seems to be in a superposition between being Foo and being Function, this is because x is being implicitly converted into a closure before being passed to callFoo. .",
    "url": "/docs/faq/type-system.html",
    "relUrl": "/docs/faq/type-system.html"
  }
  
}